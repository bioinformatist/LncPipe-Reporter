---
title: "LncPipe Reports"
author: "Yu Sun"
date: '`r date()`'
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { title: "About", href: "https://icannotendure.space/", align: right }
      - { icon: "ion-social-github", href: "https://github.com/bioinformatist/multiIP", align: right }
    theme: flatly
params:
  up.stream: 
    label: 'Input directory (results of up-stream analysis)'
    value: 'demo_results'
  output:
    label: "Output file (In HTML format)"
    value: 'reporter.html'
  cdf.percent:
    label: "Percentage of values to display when calculate coding potential"
    value: 10
    input: slider
    min: 0
    max: 100
    post: '%'
  max.lncrna.len:
    label: "Maximum length of lncRNAs to display when calculate distribution"
    value: 10000
  min.expressed.sample:
    label: "Minimal percentage of expressed samples"
    value: 50
    input: slider
    min: 0
    max: 100
    post: '%'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  fig.width = 9,
  fig.height = 6,
  cache = FALSE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE
  )
  rm(list = setdiff(ls(), "params"))
  gc()
  # The latest plotly should be used, for a lot of bugs fixed
  # if (!require("devtools")) install.packages("devtools")
  # install.packages(c("curl", "httr"))
  # devtools::install_github('ramnathv/htmlwidgets')
  # devtools::install_github("ropensci/plotly")
  # source("https://bioconductor.org/biocLite.R")
  # biocLite("edgeR")
  # library(devtools)
  # install_github("vqv/ggbiplot")
  require(plotly)
  require(data.table)
  require(cowplot)
  require(stringr)
  require(knitr)
  require(edgeR)
  require(ggbiplot)
  require(pheatmap)
  require(heatmaply)
  .toupperFirstLetter = function(x)
  paste0(toupper(substr(x, 1, 1)), tolower(substring(x, 2)))
  
```

Home
===================================== 

This is the homepage.

Quality Control
===================================== 

Column
-------------------------------------

### *FastQC* results

```{r results='asis'}
fastqc.dirs = list.files(path = params$up.stream, pattern = '_fastqc$')
fastqc.table = data.table(
Sample = substr(fastqc.dirs, 7, nchar(fastqc.dirs) - 7),
HTML = paste0(
'[',
substr(fastqc.dirs, 7, nchar(fastqc.dirs) - 7),
'](',
paste0(params$up.stream, '/', fastqc.dirs, "/fastqc_report.html"),
')'
),
Summary = paste0(
'[',
substr(fastqc.dirs, 7, nchar(fastqc.dirs) - 7),
'](',
paste0(params$up.stream, '/', fastqc.dirs, "/summary.txt"),
')'
),
Details = paste0(
'[',
substr(fastqc.dirs, 7, nchar(fastqc.dirs) - 7),
'](',
paste0(params$up.stream, '/', fastqc.dirs, "/fastqc_data.txt"),
')'
)
)
kable(fastqc.table, caption = "FastQC results")
rm(fastqc.dirs, fastqc.table)
invisible(gc())
```

Column
-------------------------------------

This is description.

STAR {data-navmenu="Aligning"}
===================================== 

```{r}
# Call perl one-liner to concatenate all log files in the list
log.summary = fread(
  paste0(
  "cd ",
  params$up.stream,
  ";grep -H '' `",
  "cat star_log.list",
  "` | perl -F':\\s{2,}|\\s\\|\\t' -lanE'/:$/ ? next : say join qq{\t}, @F'"
  ),
  header = FALSE
  )
  # Extract lines and get sample names
  log.summary <-
  log.summary[V2 %like% c('of i|Uni|mu|many l|sho|oth')] [, V1 := tstrsplit(V1, '\\.')[[1]]]
  # Convert percentage (characters) into decimals
  log.percentage <-
  log.summary[V2 %like% '%'][, ':=' (V2 = .toupperFirstLetter(gsub('% of reads | reads %', '', V2)), V3 = as.numeric(sub("%", "", V3, fixed = TRUE)) / 100)]
  setnames(log.percentage, c('Sample', 'Type', 'Percentage'))
```

Column {.tabset}
-------------------------------------

### *STAR* log plot

```{r}
p <-
  ggplot() + geom_bar(data = log.percentage,
                      aes(x = Sample, y = Percentage, fill = Type),
                      stat = 'identity') + scale_y_continuous(labels = scales::percent) + coord_flip()
# p
ggplotly(p)
rm(p)
invisible(gc())

##############################################################################################################################
# system.time(
#   log.list[V2 %like% c('Uni')]
# )
#  user  system elapsed
# 0.000   0.000   0.001

# system.time(
#   log.list[V2 %in% c('Uniquely mapped reads number', 'Uniquely mapped reads %')]
# )
#  user  system elapsed
# 0.003   0.000   0.003
##############################################################################################################################
```

### *STAR* log table

```{r}
DT::datatable(log.summary)
```

Column
-------------------------------------

This is description.

HISAT2 {data-navmenu="Aligning"}
=====================================

```{r}
hisat <- fread(
  paste0(
  "cd ",
  params$up.stream,
  ";grep -H '' `",
  "cat hisat2_log.list` |perl -F':|\\(|\\)|(>?\\d\\stimes?)' -lanE '/%/ and /aligned/ ? say join qq{\t},@F : next'"
  ),
  header = FALSE
  )
  hisat <-
  hisat[, c(1, 3, 5, 7, 8)][, ':=' (
  V1 = tstrsplit(V1, '\\.')[[1]],
  V5 =  as.numeric(sub("%", "", V5, fixed = TRUE)) / 100,
  V7 = sub(' exactly', "", V7)
  )]
  setnames(hisat, c('Sample', 'Num', 'Percentage', 'Type', 'Times'))
```

Column {.tabset}
-------------------------------------

### *HISAT* percent plot

```{r}
p <-
  ggplot() + geom_bar(data = hisat,
  aes(x = Type, y = Percentage, fill = Times),
  stat = 'identity') + scale_y_continuous(labels = scales::percent) + coord_flip() + facet_grid(Sample ~ .)
  # p
  ggplotly(p)
  rm(p)
  invisible(gc())
```

### *HISAT* log table

```{r}
DT::datatable(hisat)
rm(hisat)
```

Column
-------------------------------------

This is description.

CDF {data-navmenu="lncRNA"}
=====================================

```{r}
cdf <- fread(paste0(params$up.stream, '/CDF.txt'))
# Order first, for using geom_line later (geom_step behaves badly when calling plotly, see https://github.com/ropensci/plotly/issues/1030)
cdf <- cdf[order(cdf[, 1], cdf[, 2])]
# Subset data randomly
cdf <-
cdf[sample(nrow(cdf), nrow(cdf) * params$cdf.percent / 100),]
setnames(cdf, c('Type', 'CPAT'))
```

Column
-------------------------------------

### *CDF* against *CPAT*

```{r}
p <-
  ggplot() + geom_line(
  data = cdf,
  aes(x = CPAT, colour = Type),
  size = 2,
  stat = 'ecdf'
  ) + scale_x_continuous(expand  = c(.01, 0)) + scale_y_continuous(expand = c(0, 0)) + labs(x = 'Coding Probablity(CPAT)', title = "Coding Potential", y = "CDF") + scale_color_manual(values = c("#FFA500", "#3A5FCD", "#EE2C2C")) + geom_hline(
  yintercept = 1,
  colour = "grey",
  linetype = "dashed",
  size = 1
  )
  ggplotly(p)
  rm(p)
  invisible(gc())
```

Column
-------------------------------------

### *CPAT* table

```{r}
DT::datatable(cdf)
```

Stats {data-navmenu="lncRNA"}
=====================================

```{r parsing GTF file}
gtf <-
  fread(
  paste0(
  "sed -re 's/\\s+|;\\s+|;/\t/g' ",
  params$up.stream,
  "/lncRNA.final.v2.gtf",
  "| cut -f2,4,5,12,14"
  )
  )
  # Use sum of exon length as transcript length
  gtf <- unique(gtf[, V2 := sum(V3 - V2), by = .(V1, V4)][, V3 := NULL])
  setcolorder(gtf, c('V4', 'V1', 'V2', 'V5'))
  setnames(gtf, c('Transcript', "Type", "Length", "Distance"))
```

Column {.tabset}
-------------------------------------

### lncRNA length distribution with type

```{r}
gtf[Length > params$max.lncrna.len, Length := params$max.lncrna.len]
p <-
ggplot() + geom_density(data = gtf, aes(x = Length, colour = Type)) + xlab('Transcript length') + ylab('Density') + scale_x_continuous(
breaks = seq.int(200, params$max.lncrna.len, length.out = 10),
labels = c(
seq.int(200, params$max.lncrna.len, length.out = 9),
paste0(params$max.lncrna.len, '+')
),
expand = c(0.01, 0)
) + scale_y_continuous(expand = c(0.01, 0))
ggplotly(p) %>% layout(margin = list(r = 50))
rm(p)
invisible(gc())
```

### Total lncRNA length distribution

```{r}
p <-
ggplot() + geom_histogram(data = gtf, aes(x = Length), binwidth = 100) + scale_x_continuous(
breaks = seq.int(200, params$max.lncrna.len, length.out = 10),
labels = c(
seq.int(200, params$max.lncrna.len, length.out = 9),
paste0(params$max.lncrna.len, '+')
),
expand = c(0.01, 0)
) + scale_y_continuous(expand = c(0, 10)) + labs(x = 'lncRNA length', y = 'Count')
ggplotly(p) %>% layout(margin = list(r = 50))
rm(p)
invisible(gc())
```

### Table

```{r}
DT::datatable(gtf)
```

### lncRNA classification

```{r lncRNA classification}

```

Column
-------------------------------------

This is description.

DE analysis
=====================================

```{r}
# DE.analysis <- function(m, group) {
#   d <- DGEList(counts = rsem.count, group = group)
#   design <- model.matrix( ~ group)
#   d <-
#   d[keep <-
#   rowSums(cpm(d) > 1) >= nrow(design.table) * params$min.expressed.sample / 100, , keep.lib.sizes =
#   FALSE]
#   d <- calcNormFactors(d)
#   d <- estimateDisp(d, design = design)
#   de <- exactTest(d)
#   de <- topTags(de, n = length(rownames(de$table)))
#   deg <- row.names(de$table[with(de$table, PValue < 0.05),][order(-de$table[with(de$table, PValue < 0.05),]$logCPM),][1:20,])
#   log.cpm <- cpm(d, prior.count=2, log=TRUE)
#   log.cpm <- data.frame(log.cpm)
#   heatmap.m <- log.cpm[deg,]
#   return(list(de$table, log.cpm, heatmap.m))
# }

rsem.count <-
  fread(paste0(params$up.stream, '/lncRNA.rsem.count.txt'))
rna.id <- rsem.count[,1]
rna.type <- rsem.count[,2]
  design.table <-
  fread(paste0(params$up.stream, '/designMatrix.txt'), header = TRUE)
  rsem.count <- rsem.count[, round(.SD), .SDcols = -(1:2), with = TRUE]
  group <- as.factor(design.table$condition)
  d <- DGEList(counts = rsem.count, group = group)
  design <- model.matrix( ~ group)
  d <-
  d[keep <-
  rowSums(cpm(d) > 1) >= nrow(design.table) * params$min.expressed.sample / 100, , keep.lib.sizes =
  FALSE]
  d <- calcNormFactors(d)
  d <- estimateDisp(d, design = design)
  de <- exactTest(d)
  de <- topTags(de, n = length(rownames(de$table)))
  deg <- row.names(de$table[with(de$table, PValue < 0.05),][order(-de$table[with(de$table, PValue < 0.05),]$logCPM),][1:20,])
  log.cpm <- cpm(d, prior.count=2, log=TRUE)
  log.cpm <- data.frame(log.cpm)
  heatmap.m <- log.cpm[deg,]
```

Column 
-------------------------------------

### lncRNA length table

```{r}
DT::datatable(de$table)
```

Column {.tabset}
-------------------------------------

### Vocalno plot

```{r}
de$table$threshold <-
  as.factor(abs(de$table$logFC) > 2 & de$table$PValue < 0.05)
  p <-
  ggplot(data = de$table, aes(
  x = logFC,
  y = -log10(PValue),
  colour = threshold
  )) + geom_point(size = 1.75, alpha = 0.4) + xlab("log2 fold change") + ylab("-log10 p-value") +
  # plotly does not support expression object now
  # xlab(expression("log"[2]*"(Fold Change)")) + ylab(expression("-log"[10]*"(p-value)")) +
  geom_vline(
  xintercept = 0,
  colour = "grey",
  linetype = "dashed",
  size = 1
  ) +
  geom_hline(
  yintercept = -log10(0.05),
  colour = "grey",
  linetype = "dashed",
  size = 1
  ) + theme(legend.position = "none")
  ggplotly(p)
```

### Principle Components Analysis

```{r}
pca.m <- prcomp(t(log.cpm), scale. = FALSE)
p <-
  ggbiplot(
    pca.m,
    groups = design.table$condition,
    ellipse = TRUE,
    circle = TRUE,
    var.axes = FALSE
  )
ggplotly(p)
rm(pca.m, p)
invisible(gc())
```

### Heatmap

```{r}
# pheatmap version
# pheatmap(heatmap.m, trace = 'none', margin = c(13, 13), display_numbers = TRUE, number_format = '%.1e')

# ggplot2 %>% plotly version
# ggheatmap <- function(exprs) {
#   # https://plot.ly/ggplot2/ggdendro-dendrograms/
#   require(ggdendro)
#   # require(stringr)
#   
#   features <- row.names(exprs)
#   exprs <- t(scale(t(exprs)))
#   
#   dd.col <- as.dendrogram(hclust(dist(exprs)))
#   dd.row <- as.dendrogram(hclust(dist(t(exprs))))
#   col.order <- order.dendrogram(dd.col)
#   dy <- dendro_data(dd.col)
#   row.order <- order.dendrogram(dd.row)
#   dx <- dendro_data(dd.row)
#   
#   ggdend <- function(df) {
#   ggplot() +
#   geom_segment(data = df, aes(
#   x = x,
#   y = y,
#   xend = xend,
#   yend = yend
#   )) +
#   labs(x = "", y = "") + theme_minimal() +
#   theme(
#   axis.text = element_blank(),
#   axis.ticks = element_blank(),
#   panel.grid = element_blank()
#   )
#   }
#   
#   exprs <-
#   data.table(features, t(scale(t(exprs)))[col.order, row.order])
#   exprs <- melt(exprs, id = 1, variable.name = 'sample.name')
#   
#   dendro.data.x <- dendro_data(dd.row)
#   dendro.data.y <- dendro_data(dd.col)
#   
#   px <- ggdend(dx$segments)
#   py <- ggdend(dy$segments) + coord_flip()
#   
#   heatmap.exprs <-
#   ggplot(exprs, aes(x = sample.name, y = features)) + geom_raster(aes(fill =
#   value)) + scale_fill_gradient2(
#   low = "green",
#   mid = "black",
#   high = "red",
#   midpoint = 0
#   ) + theme(axis.ticks = element_blank(),
#   axis.text = element_text(
#   size = rel(0.4),
#   angle = 45,
#   vjust = 0
#   ))
#   
#   eaxis <- list(showticklabels = FALSE,
#   showgrid = FALSE,
#   zeroline = FALSE)
#   
#   p_empty <- plot_ly() %>%
#   # note that margin applies to entire plot, so we can
#   # add it here to make tick labels more readable
#   layout(xaxis = eaxis,
#   yaxis = eaxis)
#   
#   subplot(
#   px,
#   p_empty,
#   heatmap.exprs,
#   py,
#   nrows = 2,
#   widths = c(0.8, 0.2),
#   heights = c(0.2, 0.8)
#   )
# }
# ggheatmap(heatmap.m)
# rm(ggheatmap)

heatmaply(heatmap.m, scale = 'row', xlab = "Sample", margins = c(60,100,40,20)) %>% layout(margin = list(l = 50, b = 50))
# invisible(gc())
```

### Correlation heatmap

```{r Correlation heatmap}
# ggplot2 %>% plotly version
# p <- ggplot() + geom_raster(data = melt(cor(heatmap.m)), aes(x = Var1, y = Var2, fill = value)) + labs(x = '', y = '') + guides(fill=guide_legend(title='Cor value')) + theme(axis.text = element_text(size = rel(0.8)), axis.text.x = element_text(angle = 60, vjust = 0.7))
# ggplotly(p)

heatmaply(cor(heatmap.m), margins = c(40, 40),
          k_col = 2, k_row = 2,
          limits = c(-1,1)) %>% layout(margin = list(l = 50, b = 50))

```

Compare
=====================================

### Density

```{r compare density}
compare.dt <- data.table(Type = as.vector(t(rna.type))[as.numeric(row.names(log.cpm))], log.cpm)
p <- ggplot() + geom_density(data = melt(compare.dt, id = 'Type'), aes(x = value, colour = Type))
ggplotly(p)
```


### Violin plot

```{r compare violin}
compare.dt <- data.table(Type = as.vector(t(rna.type))[as.numeric(row.names(log.cpm))], log.cpm)
p <- ggplot() + geom_boxplot(data = melt(compare.dt, id = 'Type'), aes(x = Type, y = value), notch = TRUE)
ggplotly(p)
```

